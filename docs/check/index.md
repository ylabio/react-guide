# Чек-лист - Требования к приложению

## Вёрстка

1. Вёрстка только в компонентах в директории /components.
2. Импорт стилей только в компонентах.
3. Для разметки областей создавать компоненты Layout*. Учитывать вариативность компонентов разметки, чтобы использовать в разных местах.
4. CSS классы именовать по БЭМ методологии: 
    - `.BlockName` - название блока, соответствует названию компонента; 
    - `.BlockName_modify` - модификация стиля блока;
    - `.BlockName__elementName` - элемент блока (практически все теги внутри блока компонента); 
    - `.BlockName__elementName_modify` - модификация стиля элемента;
    - `.modify` - допускаются простые классы для модификации блока или элемента, но их определение должно быть в паре с классом блока или элемента;
5. Для комбинации классов стилей в теге использовать библиотеку `classnames`. 
6. Для подставления модификатора использовать функцию `@utils/theme`
7. Стилизация компонента через `props` - это передача названия css модификатора, а не полного имени класса и тем более не объекта стиля. Мы только указываем какой подготовленный в компоненте вариант оформления применить.

## Компоненты

1. Создаются в директории `/components`.
2. Группируются в поддиректории, чтобы проще ориентироваться в них.
3. Не надо создавать реэкспорт списка компонентов. Каждый компонент импортируется отдельной инструкцией с указанием полного пути.
4. Решают задачу как и куда вывести данные, в основном содержат вёрстку.
5. Все данные передаются в props, сам компонент ничего не узнает, он глупый.
6. Компонент глупый, но может иметь своё состояние для реализации сложной логики рендера.

## Контейнеры

1. Создаются в директории `/containers`.
2. Группируются в поддиректории, чтобы проще ориентироваться в них.
3. Содержат логику интеграции состояния приложения и функций обратного вызова на действия пользователя с компонентами. 
4. Создаются, чтобы вынести сложную или повторно используемые логику из `/app`. (из целой страницы приложения).
5. В рендере используются компоненты, html вёрстка не допускается.
6. В контейнерах не выполняется первичные загрузки данных или какие-либо инициализации в состоянии приложения. Контейнер работает с текущим состоянием, реагирует на его изменения и может вызывать экшены для его изменения (обычно в колбэках на действия пользователя)
7. Контейнерам props, обычно, не передаются. Контейнер сам берет данные из состояния приложения. 
    - Но иногда данные нужно взять от какой-либо зависимости, тогда зависимость передается контейнеру в `props`. 
        - Например для контейнера списка товаров передается идентификатор группы. При этом в состоянии приложения есть товары всех групп и нужно взять только определенную.

## Роутинг

1. Используется библиотека `react-router`
2. Маршруты описываются компонентным стилем через jsx в контейнерах `/app`. 
3. Применяется вложенность контейнеров - маршрутизация подраздела внутри контейнера подраздела. 
4. Названия подразделов соответствуют путям в маршрутах.
5. Вне директории `/app` маршрутизация не допускается.
6. В директории `/app` все контейнеры прикреплены к какому-либо маршруту.
7. Для программной навигации используется объект navigation
    - `import navigation from "@app/navigation"`
    - Применяется вместо объекта `history` из контекста компонента или хука `useHistory()`
    - Часто используемые переходы по маршрутам можно описать функцией в объекте `navigation`. 
8. Не использовать хук `useParams()` да и вообще все хуки роутера, а брать параметр роутера из `props`. 
    - Если параметр нужен вложенным контейнерам/компонентам, то пробрасывать его в их `props`.
    - Хук useParams заставит перерисовываться, даже если изменился не нужный нам параметр. 
9. search параметры адреса не рассматривать как параметры роутера. Логику работы с ними лучше перенести в экшены редакса, там где по аналогии могла быть логика работы с `localStorage`. 
10. Для получения и изменения search параметров использовать функции объекта `navigation`.

## Логика приложения

1. Декомпозируется по паттерну MVC. 
    - Состояние приложения - модель, 
    - Глупые компоненты - вид, 
    - Контейнеры в том числе в `/app` - контроллеры. 
2. Использовать функциональный стиль на хуках. 
3. Инициализация раздела всегда в хуке `useInit()` и только в контейнерах `/app`
    - Асинхронная логика
    - Например, таблица товаров вынесена в отдельный контейнер, а нем данные берутся из состояния приложения. При этом список товаров инициализируются (по апи) в соответствующем разделе `/app`. 
4. Выбираемые из состояния данные объединять в переменной `select`. 
    - Использовать хук `useSelectorMap()`
5. Все колбеки объединять в объекте `callbacks`
6. Опции для выпадашек, табов и прочего, что подготавливается перед рендером, объединять в переменной `options`.
7. Если рендер декомпозируется на отдельные функции, то попытаться вынести их в отдельные компоненты. Иначе объединить в переменной `renders`.

## Состояние и экшены

1. Используется библиотека `redux`.
    - Без применения redux-thunk и прочих оберток
2. Состояние приложения декомпозируется на модули.
    - В модуле определяются экшены, начальное состояние и редьюсеры по установке состояния.
3. **Типы экшенов** и начальное состояние описывается в отдельном файле `{module}/state.js`.
4. **Экшены** - обычные функции, которые напрямую обращаются к объекту store, вызывая dispatch.
    - Вызов экшена - это обычный вызов функции, не надо оборачивать его в dispatch.
    - Объект store можно импортировать и напрямую работать с ним. 
    - Экшены описываются в виде объекта с методами в файле `{module}/actions.js`. Может применяться описание на класса, но экспортируется экземпляр класса.
    - Классы экшенов используются для наследования типовых экшенов.
    - Файл экшенов напрямую импортируется в контейнерах для вызовов.
5. **Редьюсеры** описываются в файле `{module}/reducer.js`
    - Описываются через функцию-обертку, которой передаётся начальное состояние, типы экшенов и объект с кастомными редьюмерами. 
    - Обычно логика всех редьюсеров проста и идентична -  присвоить новый объект состояния. 
    - Используется библиотека `merge-change` для слияния состояния.
    - Файл редьюсера нужно реэкспортировать в `@store/reducers.js`
6. Модуль состояния разрабатывается по принципу “источник данных”.
    - В состоянии сами данные, параметры по которым они получены и метаданные про ошибки, ожидание и прочее.
    - Чтобы модуль загрузил/обновил данные по апи, выполняется установка параметров. Смена параметров приводит к актуализации данных в соответствии с новыми параметрами. 
    - Параметры могут быть запомнены и впоследствии восстановлены из `localStorage` (например токен юзера) или `location.search` (параметры фильтра).
    - Практически все действия пользователя - это смена параметров. Смена поискового поля - установка параметра, контейнеру с полем поиска при этом не надо вызывать загрузку данные, его задачу установить параметр.
    - Инициализация модуля - это загрузка данных по начальным параметрам. Именно это делается в хуке `useInit()`. При инициализации можно передать новые параметры.

## Интеграция API

1. Все вызовы апи описываются функциями в директории `/api`. Именно они вызываются в коде приложения.
2. На каждый ресурс описывается отдельный класс с функциями API.
3. Для типового CRUD API ресурса наследовать базовый класс (`Base` или `Common`).
4. Для интеграции с несколькими апи нужно создавать соответствующее количество отдельных директорий с описанием апи.

## Код

1. Общие правила определены в `eslint`, могут меняться.
2. Для автоформатирования используется `prettier`
3. Отступы в два пробела
4. Названия файлов и директорий в нижнем регистре через дефис. kebab стиль.
5. Файлы компонент, модулей, библиотек и потенциально расширяемых на несколько файлов частей кода, группировать в директории.
    - Название директории - это название компонента, модуля.. 
    - Файлы внутри директории не должны содержать названия компонента, модуля... Их названия - это именование составной части компонента, модуля: `index.js`, `style.less`, `favicon.png`
6. В одном файле кода содержится логика с однозначным назначением, не должно быть кучи все в одном месте. 
7. Упорядочивать функции в классе (объекте) по приоритету и последовательности исполнения. Чтобы логика читалась сверху внизу, а не хаотично. Открыв файл желательно сразу увидеть его главную функцию. Второстепенные функции лучше описывать внизу. Но также учитывать порядок исполнения функций. Например рендер - это последнее что делает компонент и эту функцию мы всегда ищем в конце файла.
8. Логика на замыканиях (в частности хуках) должна быть четко сгруппирована на логические блоки. Получение данных, описание колбэков, инициализация опций, вынесенные функции-рендеры.
    - Не в коем случаи не писать где попало новый хук, объявлять переменную. Разработчик должен интуитивно знать, где искать определение функции или переменной.
9. Импорт файлов приложения через алиас `"@"` вместо относительных путей. Пути алиаса указываются в `package.json`
