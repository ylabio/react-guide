# Контейнеры

1. Контейнеры - это **умные** [компоненты](/docs/check/component.md) или контроллеры. 

2. Контейнер знает всё об окружении, сам берёт данные и вызывает действия, направляет данные компонентами и обрабатывает их события.

3. В контейнере не допускается вёрстка на html и css. Вместо неё используются компоненты.

4. Создаются в директориях `/containers` и `/app`. 
    - `/app` — контейнеры цельных страниц или разделов.
    - `/containers` — повторно используемые фрагменты страниц или вынесенная из страниц сложная логика.

5. Именование, функциональный стиль, мемомизация — всё как у [компонента](/docs/check/component.md).

6. Контейнерам через `props` не передаются данные, только параметры, от которых зависит логика контейнера. 
   Например, идентификатор, по которому из стейта будут выбраны все свойства конкретного объекта или вызваны действия.

7. Логика инициализации реализуется хуком **`useInit()`** вместо `useEffect()`. По умолчанию, этот хук вызывается единственный 
   раз при первом рендере контейнера, если не указана зависимость на параметры. Позволяет вызывать асинхронные действия и 
   учитывает их при [серверном рендере](/docs/develop/ssr/index.md). Может отслеживать переходы назад/вперед по истории браузера, 
   когда меняются search параметры адреса. Так же по коду будет больше ясности.
   ```js
   import useInit from '@utils/hooks/use-init';
   //..
   useInit(async () => {
      // загружаем товары при первом рендере контейнера или когда меняется categoryId
      await articles.init({ categoryId });
   }, [categoryId]);
   
   useInit(async () => {
     // Загружаем категории только при первом рендере контейнера
     await categories.load({ limit: 1000 });
   });
   ```

8. Избегать каскадов инициализации, когда вложенный контейнер рендерится после инициализации родительского контейнера, и 
  запускает свою инициализацию. Все инициализации должны происходить в контейнере-странице в `/app`. Контейнеры в
  `/containers` должны сразу выбирать данные из стейта.

9. В `/app` не должно быть контейнеров без привязки к маршруту навигации (роутингу или другим вариантам). 
   Структура директорий в `/app` соответствует карте сайта.

10. В `/containers` используются поддиректории для группировки контейнеров по общим признакам. 
    Чтобы легче ориентироваться как в директории компонент.
    
11. Декомпозировать контейнеры для уменьшения зависимостей рендера. Например, из контейнера страницы каталога
   выносить в отдельные контейнеры таблицу товаров и контейрер с фильтами. Каждый контейнер будет выполнять свою часть
   работы. При обновлении параметра фильтра, обновится толкьо контейнер фильтров. Подгрузятся новые товары — обновится 
   только контейнер таблицы.

*Страница каталога*
```js
function Catalog(props) {
  
  // Только инициализация каталога. Страница не выводит товары - делегирует вложенным контейнерам
  useInit(async () => {
    await articles.init({ categoryId: props.match.params.categoryId });
  }, [props.match.params.categoryId]);

  useInit(async () => {
    await categories.load({ fields: '*', limit: 1000 });
  });

  return (
    <LayoutPage header={<HeaderContainer />}>
      <LayoutContent>
        <CategoryTree />
        <ArticleList />
      </LayoutContent>
    </LayoutPage>
  );
}
```

*Фильтр по категории*
```js
function CategoryTree(){
   // Контейнер дерева категорий только берет катеогрии из стейта и передаёт в компонент  
  const select = useSelectorMap(state => ({
    roots: state.categories.roots,
    wait: state.categories.wait,
  }));
  
  const renders = {
    // Кастомный рендер пункта в дереве
    item: useCallback(item => {
      return <Link to={`/catalog/${item._id}`}>{item.title}</Link>;
    }, [select.roots])
  };

  return (
     <Tree
        items={select.roots}
        renderItem={renders.item}
     />
  );
}
```

*Список товаров*
```js
function ArticleList() {
  // Берем товары и передаём в компонент списка 
  const select = useSelectorMap(state => ({
    items: state.articles.items,
    wait: state.articles.wait,
  }));
  
  const renders = {
    card: useCallback(item => {
      return <ArticleCard data={item}/>;
    }, [select.items])
  };

  return <List items={select.items} renderItem={renders.card}/>
}
```
